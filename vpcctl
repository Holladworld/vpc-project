#!/bin/bash

set -e

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG_DIR="${SCRIPT_DIR}/config/vpc_configs"
LOG_FILE="${SCRIPT_DIR}/vpc_operations.log"
FIREWALL_RULES="${SCRIPT_DIR}/config/firewall_rules.json"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Logging function
log() {
    echo -e "${BLUE}[$(date '+%Y-%m-%d %H:%M:%S')]${NC} $*" | tee -a "$LOG_FILE"
}

success() {
    echo -e "${GREEN}✓${NC} $*" | tee -a "$LOG_FILE"
}

warning() {
    echo -e "${YELLOW}!${NC} $*" | tee -a "$LOG_FILE"
}

error() {
    echo -e "${RED}✗${NC} $*" | tee -a "$LOG_FILE"
}

error_exit() {
    error "$1"
    exit 1
}

# Check root privileges
check_privileges() {
    if [[ $EUID -ne 0 ]]; then
        error_exit "This script must be run as root for network operations"
    fi
}

# Check dependencies
check_dependencies() {
    local deps=("ip" "iptables" "bridge" "jq" "python3")
    for dep in "${deps[@]}"; do
        if ! command -v "$dep" &> /dev/null; then
            error "Dependency $dep not found"
            if [[ "$dep" == "jq" ]]; then
                log "Installing jq..."
                apt-get update && apt-get install -y jq
            fi
        fi
    done
    success "All dependencies satisfied"
}

# Initialize environment
init_environment() {
    mkdir -p "$CONFIG_DIR"
    log "Initializing VPC environment..."
    
    # Enable IP forwarding
    echo 1 > /proc/sys/net/ipv4/ip_forward
    sysctl -w net.ipv4.ip_forward=1 > /dev/null 2>&1
    
    # Create default firewall rules if not exists
    if [[ ! -f "$FIREWALL_RULES" ]]; then
        mkdir -p "$(dirname "$FIREWALL_RULES")"
        cat > "$FIREWALL_RULES" << 'EOF'
{
  "rules": [
    {
      "subnet": "10.0.1.0/24",
      "ingress": [
        {"port": 80, "protocol": "tcp", "action": "allow"},
        {"port": 443, "protocol": "tcp", "action": "allow"},
        {"port": 22, "protocol": "tcp", "action": "deny"}
      ]
    },
    {
      "subnet": "10.0.2.0/24",
      "ingress": [
        {"port": 22, "protocol": "tcp", "action": "allow"},
        {"port": 80, "protocol": "tcp", "action": "deny"}
      ]
    }
  ]
}
EOF
        success "Created default firewall rules"
    fi
}

# VPC Creation
create_vpc() {
    local vpc_name="$1"
    local cidr_block="$2"
    
    if [[ -z "$vpc_name" || -z "$cidr_block" ]]; then
        error_exit "Usage: create-vpc <vpc_name> <cidr_block>"
    fi
    
    log "Creating VPC: $vpc_name with CIDR: $cidr_block"
    
    # Validate CIDR format
    if ! [[ "$cidr_block" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+/[0-9]+$ ]]; then
        error_exit "Invalid CIDR format: $cidr_block"
    fi
    
    local bridge_name="br-${vpc_name}"
    
    # Check if VPC already exists
    if ip link show "$bridge_name" >/dev/null 2>&1; then
        error_exit "VPC $vpc_name already exists"
    fi
    
    # Create bridge
    ip link add "$bridge_name" type bridge
    ip addr add "${cidr_block%/*}.1/32" dev "$bridge_name"
    ip link set "$bridge_name" up
    
    # Save VPC configuration
    cat > "${CONFIG_DIR}/${vpc_name}.conf" << EOF
VPC_NAME="$vpc_name"
CIDR_BLOCK="$cidr_block"
BRIDGE_NAME="$bridge_name"
CREATED_AT="$(date)"
SUBNETS=()
EOF
    
    success "VPC $vpc_name created with bridge $bridge_name"
}

# Subnet Creation
add_subnet() {
    local vpc_name="$1"
    local subnet_type="$2"
    local subnet_cidr="$3"
    
    if [[ -z "$vpc_name" || -z "$subnet_type" || -z "$subnet_cidr" ]]; then
        error_exit "Usage: add-subnet <vpc_name> <subnet_type> <subnet_cidr>"
    fi
    
    local config_file="${CONFIG_DIR}/${vpc_name}.conf"
    [[ ! -f "$config_file" ]] && error_exit "VPC $vpc_name not found"
    
    source "$config_file"
    
    local namespace="ns-${vpc_name}-${subnet_type}"
    local veth_host="veth-${vpc_name}-${subnet_type}-host"
    local veth_ns="veth-${vpc_name}-${subnet_type}-ns"
    local bridge_name="$BRIDGE_NAME"
    
    log "Adding $subnet_type subnet $subnet_cidr to VPC $vpc_name"
    
    # Create network namespace
    ip netns add "$namespace"
    
    # Create veth pair
    ip link add "$veth_host" type veth peer name "$veth_ns"
    
    # Configure host side
    ip link set "$veth_host" up
    ip link set "$veth_host" master "$bridge_name"
    
    # Configure namespace side
    ip netns exec "$namespace" ip link set lo up
    ip netns exec "$namespace" ip link set "$veth_ns" up
    ip netns exec "$namespace" ip addr add "$subnet_cidr" dev "$veth_ns"
    
    # Calculate gateway IP (first IP in subnet)
    local gateway_ip="${subnet_cidr%.*}.1"
    ip netns exec "$namespace" ip route add default via "$gateway_ip"
    
    # Add bridge IP for this subnet if not exists
    if ! ip addr show "$bridge_name" | grep -q "$gateway_ip"; then
        ip addr add "$gateway_ip/32" dev "$bridge_name"
    fi
    
    # Setup NAT for public subnets
    if [[ "$subnet_type" == "public" ]]; then
        setup_nat "$vpc_name" "$namespace" "$subnet_cidr"
    fi
    
    # Update configuration
    if ! grep -q "SUBNET_${subnet_type}" "$config_file"; then
        echo "SUBNET_${subnet_type}=$subnet_cidr" >> "$config_file"
        echo "NAMESPACE_${subnet_type}=$namespace" >> "$config_file"
    fi
    
    # Add to SUBNETS array
    sed -i "/^SUBNETS=/s/)/ $subnet_cidr)/" "$config_file"
    
    success "Subnet $subnet_type ($subnet_cidr) created in namespace $namespace"
}

# NAT Configuration
setup_nat() {
    local vpc_name="$1"
    local namespace="$2"
    local subnet_cidr="$3"
    
    local bridge_name="br-${vpc_name}"
    
    log "Setting up NAT for public subnet $subnet_cidr"
    
    # Enable forwarding in namespace
    ip netns exec "$namespace" sysctl -w net.ipv4.ip_forward=1 > /dev/null 2>&1
    
    # Find host internet interface
    local internet_interface=$(ip route | grep default | awk '{print $5}' | head -1)
    [[ -z "$internet_interface" ]] && internet_interface="eth0"
    
    # Configure iptables for NAT
    iptables -t nat -A POSTROUTING -s "$subnet_cidr" ! -o "$bridge_name" -j MASQUERADE 2>/dev/null || true
    
    # Allow forwarding
    iptables -A FORWARD -i "$bridge_name" -o "$bridge_name" -j ACCEPT 2>/dev/null || true
    iptables -A FORWARD -s "$subnet_cidr" -j ACCEPT 2>/dev/null || true
    iptables -A FORWARD -i "$bridge_name" -o "$internet_interface" -j ACCEPT 2>/dev/null || true
    iptables -A FORWARD -i "$internet_interface" -o "$bridge_name" -m state --state RELATED,ESTABLISHED -j ACCEPT 2>/dev/null || true
    
    success "NAT configured for public subnet (internet interface: $internet_interface)"
}

# VPC Peering
create_peering() {
    local vpc1="$1"
    local vpc2="$2"
    
    [[ -z "$vpc1" || -z "$vpc2" ]] && error_exit "Usage: create-peering <vpc1> <vpc2>"
    
    local peer_name="peer-${vpc1}-${vpc2}"
    local veth1="veth-${vpc1}-${vpc2}"
    local veth2="veth-${vpc2}-${vpc1}"
    local br1="br-${vpc1}"
    local br2="br-${vpc2}"
    
    log "Creating VPC peering between $vpc1 and $vpc2"
    
    # Check if bridges exist
    ip link show "$br1" >/dev/null 2>&1 || error_exit "VPC $vpc1 not found"
    ip link show "$br2" >/dev/null 2>&1 || error_exit "VPC $vpc2 not found"
    
    # Create veth pair for peering
    ip link add "$veth1" type veth peer name "$veth2"
    
    # Connect to bridges
    ip link set "$veth1" master "$br1"
    ip link set "$veth2" master "$br2"
    
    ip link set "$veth1" up
    ip link set "$veth2" up
    
    # Get CIDR blocks for routing
    source "${CONFIG_DIR}/${vpc1}.conf"
    local cidr1="$CIDR_BLOCK"
    source "${CONFIG_DIR}/${vpc2}.conf"
    local cidr2="$CIDR_BLOCK"
    
    success "VPC peering created between $vpc1 ($cidr1) and $vpc2 ($cidr2)"
}

# Firewall Rules
apply_firewall() {
    local vpc_name="$1"
    local rules_file="${2:-$FIREWALL_RULES}"
    
    [[ ! -f "$rules_file" ]] && error_exit "Rules file $rules_file not found"
    
    log "Applying firewall rules from $rules_file to VPC $vpc_name"
    
    # Parse and apply rules
    local rules_count=$(jq '.rules | length' "$rules_file")
    
    for ((i=0; i<rules_count; i++)); do
        local subnet=$(jq -r ".rules[$i].subnet" "$rules_file")
        local namespace=$(find_namespace_by_subnet "$vpc_name" "$subnet")
        
        if [[ -n "$namespace" ]]; then
            apply_namespace_rules "$namespace" "$rules_file" "$i"
        else
            warning "No namespace found for subnet $subnet in VPC $vpc_name"
        fi
    done
    
    success "Firewall rules applied to VPC $vpc_name"
}

find_namespace_by_subnet() {
    local vpc_name="$1"
    local subnet="$2"
    local config_file="${CONFIG_DIR}/${vpc_name}.conf"
    
    [[ ! -f "$config_file" ]] && return
    
    source "$config_file"
    
    if [[ "$SUBNET_public" == "$subnet" ]]; then
        echo "$NAMESPACE_public"
    elif [[ "$SUBNET_private" == "$subnet" ]]; then
        echo "$NAMESPACE_private"
    fi
}

apply_namespace_rules() {
    local namespace="$1"
    local rules_file="$2"
    local rule_index="$3"
    
    local subnet=$(jq -r ".rules[$rule_index].subnet" "$rules_file")
    local ingress_count=$(jq -r ".rules[$rule_index].ingress | length" "$rules_file")
    
    log "Applying rules to namespace $namespace (subnet: $subnet)"
    
    # Clear existing rules in the namespace
    ip netns exec "$namespace" iptables -F
    ip netns exec "$namespace" iptables -X
    
    # Default policies
    ip netns exec "$namespace" iptables -P INPUT DROP
    ip netns exec "$namespace" iptables -P FORWARD DROP
    ip netns exec "$namespace" iptables -P OUTPUT ACCEPT
    
    # Allow established connections
    ip netns exec "$namespace" iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
    ip netns exec "$namespace" iptables -A FORWARD -m state --state ESTABLISHED,RELATED -j ACCEPT
    
    # Allow loopback
    ip netns exec "$namespace" iptables -A INPUT -i lo -j ACCEPT
    
    # Apply specific rules
    for ((j=0; j<ingress_count; j++)); do
        local port=$(jq -r ".rules[$rule_index].ingress[$j].port" "$rules_file")
        local protocol=$(jq -r ".rules[$rule_index].ingress[$j].protocol" "$rules_file")
        local action=$(jq -r ".rules[$rule_index].ingress[$j].action" "$rules_file")
        
        if [[ "$action" == "allow" ]]; then
            ip netns exec "$namespace" iptables -A INPUT -p "$protocol" --dport "$port" -j ACCEPT
            log "  Allowed $protocol port $port"
        else
            ip netns exec "$namespace" iptables -A INPUT -p "$protocol" --dport "$port" -j DROP
            log "  Blocked $protocol port $port"
        fi
    done
}

# VPC Deletion
delete_vpc() {
    local vpc_name="$1"
    [[ -z "$vpc_name" ]] && error_exit "Usage: delete-vpc <vpc_name>"
    
    local config_file="${CONFIG_DIR}/${vpc_name}.conf"
    [[ ! -f "$config_file" ]] && error_exit "VPC $vpc_name not found"
    
    log "Deleting VPC: $vpc_name"
    
    source "$config_file"
    
    # Delete namespaces
    for subnet_type in public private; do
        local var_name="NAMESPACE_${subnet_type}"
        local namespace="${!var_name}"
        if [[ -n "$namespace" ]]; then
            ip netns delete "$namespace" 2>/dev/null && log "Deleted namespace: $namespace"
        fi
    done
    
    # Delete bridge
    ip link delete "$BRIDGE_NAME" 2>/dev/null && log "Deleted bridge: $BRIDGE_NAME"
    
    # Remove configuration
    rm -f "$config_file"
    
    success "VPC $vpc_name completely deleted"
}

# List VPCs
list_vpcs() {
    log "Available VPCs:"
    if [[ -d "$CONFIG_DIR" ]] && ls "$CONFIG_DIR"/*.conf >/dev/null 2>&1; then
        for config_file in "$CONFIG_DIR"/*.conf; do
            source "$config_file"
            echo "VPC: $VPC_NAME"
            echo "  CIDR: $CIDR_BLOCK"
            echo "  Bridge: $BRIDGE_NAME"
            echo "  Created: $CREATED_AT"
            [[ -n "$SUBNET_public" ]] && echo "  Public Subnet: $SUBNET_public"
            [[ -n "$SUBNET_private" ]] && echo "  Private Subnet: $SUBNET_private"
            echo
        done
    else
        warning "No VPCs found"
    fi
}

# Main command dispatcher
main() {
    check_privileges
    check_dependencies
    init_environment
    
    case "$1" in
        create-vpc)
            create_vpc "$2" "$3"
            ;;
        delete-vpc)
            delete_vpc "$2"
            ;;
        add-subnet)
            add_subnet "$2" "$3" "$4"
            ;;
        list-vpcs)
            list_vpcs
            ;;
        create-peering)
            create_peering "$2" "$3"
            ;;
        delete-peering)
            warning "Peering deletion not yet implemented"
            ;;
        apply-firewall)
            apply_firewall "$2" "$3"
            ;;
        status)
            list_vpcs
            ;;
        *)
            echo "Usage: $0 {create-vpc|delete-vpc|add-subnet|list-vpcs|create-peering|apply-firewall|status}"
            echo ""
            echo "Examples:"
            echo "  $0 create-vpc my-vpc 10.0.0.0/16"
            echo "  $0 add-subnet my-vpc public 10.0.1.0/24"
            echo "  $0 add-subnet my-vpc private 10.0.2.0/24"
            echo "  $0 apply-firewall my-vpc"
            echo "  $0 list-vpcs"
            echo "  $0 delete-vpc my-vpc"
            exit 1
            ;;
    esac
}

# Run main function with all arguments
main "$@"